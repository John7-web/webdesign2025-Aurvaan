<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Black Hole Simulation</title>
    <style>
        html, body { min-height: 100%; margin: 0; overflow-x: hidden; background-color: #000; }
        body { display: flex; flex-direction: column; }

        /* Canvas container takes available space above the info panel and keeps a healthy minimum height */
        .canvas-container { flex: 1; position: relative; min-height: clamp(300px, 60vh, 720px); }
        #blackhole-canvas { width: 100%; height: 100%; }
        /* Force the renderer canvas to fully fill the container and avoid stretching artifacts */
        #blackhole-canvas canvas { display: block; width: 100% !important; height: 100% !important; }

        /* Loading text */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; pointer-events: none;
            transition: opacity 0.5s; z-index: 12;
        }

        /* Bottom information panel (collapsible) */
        #info-bottom { 
            background: rgba(6,6,8,0.95);
            color: #fff;
            padding: 14px 18px;
            font-family: sans-serif;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.6);
            position: relative;
            overflow: hidden;
            max-height: 280px; /* expanded */
            transition: max-height 300ms ease, padding 300ms ease;
        }

        /* Collapsed state */
        #info-bottom.collapsed {
            max-height: 44px; /* small bar */
            padding-top: 8px;
            padding-bottom: 8px;
        }

        #info-bottom h2 { margin: 0 0 6px 0; font-size: 1rem; }
        #info-bottom h3 { margin: 8px 0 6px 0; font-size: 0.95rem; color: #fff; }
        #info-bottom p { margin: 6px 0 8px 0; color:#ddd; font-size:0.95rem; }
        #info-bottom ul { margin: 4px 0 0 18px; color:#ddd; }
        #info-bottom .info-section { margin-top: 8px; color: #ddd; }
        #info-bottom hr { border: none; border-top: 1px solid rgba(255,255,255,0.06); margin: 10px 0; }

        /* Toggle button */
        .info-toggle {
            position: absolute;
            right: 10px;
            top: 8px;
            background: rgba(20,20,22,0.25);
            border: 1px solid rgba(255,255,255,0.06);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            line-height: 1;
            backdrop-filter: blur(4px);
        }

        @media (max-width:700px) {
            .canvas-container { min-height: 240px; }
            #info-bottom { padding: 12px; font-size: 0.95rem; }
            #content { margin: 12px 12px 72px; padding: 14px; }
        }

        /* Research / content area */
        #content {
            max-width: 920px;
            margin: 18px auto 88px;
            padding: 20px;
            background: rgba(255,255,255,0.02);
            border-radius: 8px;
            box-shadow: 0 6px 30px rgba(0,0,0,0.6);
            color: #ddd;
            line-height: 1.6;
        }
        #content h1, #content h2 { color: #fff; margin: 0.6rem 0 0.4rem; }
        #content p, #content ul { margin: 0.5rem 0; color: #cfd8dc; }
        #content ul { padding-left: 1.2rem; }
        #content small { color: #9ea7ab; }
    </style>
    <!-- Import Map for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div class="canvas-container">
        <div id="loading">Initializing Singularity...</div>
        <div id="blackhole-canvas"></div>
    </div>

  
    </aside>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            diskCount: 80000,        // Number of particles in the disk
            starCount: 2000,         // Background stars
            diskInner: 3.5,          // Inner radius of disk
            diskOuter: 12.0,         // Outer radius of disk
            bloomStrength: 1.5,      // Glow intensity
            bloomRadius: 0.4,        // Glow spread
            bloomThreshold: 0.1      // Brightness threshold for glow
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // Fade distant stars
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 14);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); // Bloom handles AA essentially
        const canvasContainer = document.getElementById('blackhole-canvas');
        // Initial size from container
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        canvasContainer.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Post-Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(canvasContainer.clientWidth, canvasContainer.clientHeight),
            CONFIG.bloomStrength,
            CONFIG.bloomRadius,
            CONFIG.bloomThreshold
        );

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 1. The Event Horizon (Black Hole) ---
        const blackHoleGeometry = new THREE.SphereGeometry(3, 64, 64);
        const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
        scene.add(blackHole);

        // --- 2. The Accretion Disk (Particle Shader) ---
        // We use a custom shader to handle differential rotation (inner spins faster) efficiently on GPU
        
        const diskGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.diskCount * 3);
        const sizes = new Float32Array(CONFIG.diskCount);
        const colors = new Float32Array(CONFIG.diskCount * 3);
        const offsets = new Float32Array(CONFIG.diskCount); // Random offset for variation

        const colorInside = new THREE.Color(0xffaa55); // Hot/Bright
        const colorOutside = new THREE.Color(0xaa2200); // Cooler/Red

        for (let i = 0; i < CONFIG.diskCount; i++) {
            // Distribute particles in a ring
            const r = CONFIG.diskInner + Math.random() * (CONFIG.diskOuter - CONFIG.diskInner);
            const angle = Math.random() * Math.PI * 2;
            
            // Flatten the disk but give it slight volume
            // We concentrate particles closer to the center for brightness
            const spread = 0.1 + (r - CONFIG.diskInner) * 0.05; 
            const y = (Math.random() - 0.5) * spread;

            positions[i * 3] = Math.cos(angle) * r;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = Math.sin(angle) * r;

            // Size variation
            sizes[i] = Math.random();

            // Color gradient based on radius
            const t = (r - CONFIG.diskInner) / (CONFIG.diskOuter - CONFIG.diskInner);
            const mixedColor = colorInside.clone().lerp(colorOutside, t);
            
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;

            offsets[i] = Math.random() * 100;
        }

        diskGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        diskGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        diskGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        diskGeometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));

        const diskMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uPixelRatio: { value: renderer.getPixelRatio() }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uPixelRatio;
                attribute float size;
                attribute float aOffset;
                attribute vec3 color; 
                varying vec3 vColor;

                void main() {
                    vColor = color;
                    
                    vec3 pos = position;
                    
                    // Differential Rotation Logic
                    // Calculate distance from center (radius)
                    float r = length(pos.xz);
                    
                    // Speed is inversely proportional to radius (Keplerian-ish)
                    // Closer = Faster
                    float speed = 8.0 / (r * r); 
                    
                    // Current angle
                    float angle = atan(pos.z, pos.x);
                    
                    // New angle based on time
                    float newAngle = angle + (speed * uTime * 0.5); // 0.5 is global speed scale
                    
                    // Apply rotation
                    pos.x = cos(newAngle) * r;
                    pos.z = sin(newAngle) * r;

                    // Add a tiny bit of vertical wave motion
                    pos.y += sin(uTime * 2.0 + aOffset) * 0.02;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    // Size attenuation (particles get smaller when further away)
                    gl_PointSize = size * uPixelRatio * (80.0 / -mvPosition.z);
                    
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                
                void main() {
                    // Circular soft particle
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if (r > 0.5) discard;
                    
                    // Soft edge glow
                    float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                    alpha = pow(alpha, 2.0); // Make it sharper

                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // Glow effect blend
        });

        const accretionDisk = new THREE.Points(diskGeometry, diskMaterial);
        scene.add(accretionDisk);

        // --- 3. Photon Ring (Inner Glow) ---
        // A thin glowing ring right at the edge of the black hole
        const ringGeo = new THREE.RingGeometry(3.0, 3.2, 64);
        const ringMat = new THREE.MeshBasicMaterial({ 
            color: 0xffddaa, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.5,
            blending: THREE.AdditiveBlending
        });
        const photonRing = new THREE.Mesh(ringGeo, ringMat);
        photonRing.rotation.x = Math.PI / 2;
        // We slightly tilt it or make it look at camera to simulate the sphere of light
        // For simplicity, we just add it flat to the disk for the "core" brightness
        scene.add(photonRing);


        // --- 4. Starfield Background ---
        const starsGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<CONFIG.starCount; i++) {
            const x = (Math.random() - 0.5) * 400;
            const y = (Math.random() - 0.5) * 400;
            const z = (Math.random() - 0.5) * 400;
            // Keep stars away from the center to avoid clipping with the hole
            if (Math.sqrt(x*x + y*y + z*z) > 50) {
                starPos.push(x, y, z);
            }
        }
        starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, sizeAttenuation: true });
        const starField = new THREE.Points(starsGeo, starsMat);
        scene.add(starField);


        // --- Resize Handler & Layout Observer ---
        function updateSize() {
            const width = canvasContainer.clientWidth || window.innerWidth;
            const height = canvasContainer.clientHeight || window.innerHeight;

            // Enforce a reasonable minimum height so the black hole doesn't get squished
            const finalHeight = Math.max(height, 300);

            camera.aspect = width / finalHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(width, finalHeight);
            composer.setSize(width, finalHeight);
            diskMaterial.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        }

        // Keep this for window-level resizes
        window.addEventListener('resize', updateSize);

        // Use ResizeObserver to handle DOM layout changes that don't trigger window resize
        if (typeof ResizeObserver !== 'undefined') {
            const ro = new ResizeObserver(() => updateSize());
            ro.observe(canvasContainer);
        }

        // Ensure renderer uses the correct size from the start
        updateSize();

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Update Shader Uniforms
            diskMaterial.uniforms.uTime.value = elapsedTime;

            // Make the photon ring always face the camera slightly to look volumetric
            photonRing.lookAt(camera.position);

            controls.update();
            
            // Render via Composer (for Bloom)
            composer.render();
        }

        // Hide loading text once things start
        document.getElementById('loading').style.opacity = '0';
        
        // Populate the info panel with values from CONFIG
        const elDiskCount = document.getElementById('paramDiskCount');
        const elStarCount = document.getElementById('paramStarCount');
        const elDiskInner = document.getElementById('paramDiskInner');
        const elDiskOuter = document.getElementById('paramDiskOuter');

        if (elDiskCount) elDiskCount.textContent = CONFIG.diskCount.toLocaleString();
        if (elStarCount) elStarCount.textContent = CONFIG.starCount.toLocaleString();
        if (elDiskInner) elDiskInner.textContent = CONFIG.diskInner;
        if (elDiskOuter) elDiskOuter.textContent = CONFIG.diskOuter;

        // Collapsible info panel behavior
        const infoPanel = document.getElementById('info-bottom');
        const toggleBtn = document.getElementById('infoToggle');
        function setToggleState(collapsed) {
            // collapsed = true means panel is minimized
            if (toggleBtn) {
                toggleBtn.setAttribute('aria-expanded', (!collapsed).toString());
                toggleBtn.textContent = collapsed ? '▼' : '▲';
                toggleBtn.title = collapsed ? 'Expand panel' : 'Collapse panel';
            }
        }
        if (infoPanel && toggleBtn) {
            // initialize
            const isCollapsed = infoPanel.classList.contains('collapsed');
            setToggleState(isCollapsed);

            toggleBtn.addEventListener('click', () => {
                const collapsed = infoPanel.classList.toggle('collapsed');
                setToggleState(collapsed);
                // update renderer/camera after transition finishes
                setTimeout(() => updateSize(), 320);
            });

            // double-click panel to toggle
            infoPanel.addEventListener('dblclick', () => {
                const collapsed = infoPanel.classList.toggle('collapsed');
                setToggleState(collapsed);
                setTimeout(() => updateSize(), 320);
            });
        }

        animate();
    </script>
</body>
</html>