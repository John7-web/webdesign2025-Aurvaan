<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Physics Horse Simulator</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Cannon.js for physics simulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- Load GLTFLoader for complex 3D models -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark background */
        }
        #info-box {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            font-size: 1rem;
            text-align: center;
            z-index: 10;
            /* Added flex for internal layout of text and button */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <div id="info-box" class="shadow-xl">
    
        <!-- NEW BUTTON ADDED HERE -->
        <button id="throw-button" onclick="throwAllHorses()" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition duration-200 transform hover:scale-105 active:scale-95">
            LAUNCH THE HERD!
        </button>
    </div>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let world, groundBody, groundMesh;
        let raycaster, mouse, plane;
        let isDragging = false;
        let constraint, mouseBody;
        let draggedHorseBody = null; // Track the horse currently being dragged
        let horseBodies = []; // Array to hold all Cannon bodies
        let horseMeshes = []; // Array to hold all Three meshes
        
        let clock = new THREE.Clock();
        const timeStep = 1 / 60;

        // Velocity tracking for throwing
        let lastMousePos = new THREE.Vector2();
        let currentMousePos = new THREE.Vector2();
        const velocityHistory = [];

        // --- Utility Functions ---

        /**
         * Converts normalized device coordinates to a 3D world position on a specified plane.
         * @param {THREE.Vector2} normalizedCoords - Normalized device coordinates (-1 to 1).
         * @param {THREE.Plane} projectionPlane - The plane to intersect with.
         * @returns {THREE.Vector3 | null} The intersection point or null.
         */
        function getWorldPosition(normalizedCoords, projectionPlane) {
            raycaster.setFromCamera(normalizedCoords, camera);
            const intersection = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(projectionPlane, intersection)) {
                return intersection;
            }
            return null;
        }

        /**
         * Calculates a throwing impulse based on the change in mouse position.
         * Uses the mass of the currently dragged horse.
         * @returns {THREE.Vector3} The calculated impulse vector.
         */
        function calculateThrowImpulse() {
            if (velocityHistory.length < 2 || !draggedHorseBody) return new THREE.Vector3(0, 0, 0);

            // Simple average velocity over the last few frames
            let totalVelocity = new THREE.Vector3(0, 0, 0);
            for (let i = 1; i < velocityHistory.length; i++) {
                const { pos: current, time: t1 } = velocityHistory[i];
                const { pos: prev, time: t0 } = velocityHistory[i - 1];

                const dt = (t1 - t0) / 1000; // time delta in seconds
                if (dt > 0) {
                    const dx = (current.x - prev.x) / dt;
                    const dy = (current.y - prev.y) / dt;
                    const dz = (current.z - prev.z) / dt;
                    totalVelocity.add(new THREE.Vector3(dx, dy, dz));
                }
            }

            const avgVelocity = totalVelocity.divideScalar(velocityHistory.length - 1);

            // Apply a multiplier for a satisfying throw
            const impulseMultiplier = 3; // Weak throwing power
            return avgVelocity.multiplyScalar(draggedHorseBody.mass * impulseMultiplier);
        }

        /**
         * Applies a large, random impulse to all horses, throwing them across the scene.
         */
        function throwAllHorses() {
            const forceMagnitude = 30; // Strong magnitude for mass=1.0 horses
            horseBodies.forEach(body => {
                // Generate a random vector for direction
                const randomX = (Math.random() - 0.5) * 2; // -1 to 1
                const randomY = Math.random() * 1.5 + 1; // 1.0 to 2.5 (mostly upwards)
                const randomZ = (Math.random() - 0.5) * 2; // -1 to 1

                const direction = new THREE.Vector3(randomX, randomY, randomZ).normalize();
                
                // Scale the direction by the desired magnitude
                const impulseVector = direction.multiplyScalar(forceMagnitude);

                // Apply the impulse at the center of mass
                body.applyImpulse(
                    new CANNON.Vec3(impulseVector.x, impulseVector.y, impulseVector.z), 
                    body.position
                );
                
                // Also give a random angular velocity for spinning chaos
                body.angularVelocity.set(
                    (Math.random() - 0.5) * 15, // Increased spin for chaos
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 15
                );
            });
        }


        // --- Setup Functions ---

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Interaction Setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Ground plane for dragging

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
        }

        function initCannon() {
            // World
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            // Increased solver iterations from 10 to 20 for maximum contact resolution accuracy
            world.solver.iterations = 20; 

            // Materials 
            const groundMaterial = new CANNON.Material('groundMaterial');
            const horseMaterial = new CANNON.Material('horseMaterial');
            const horseGroundContact = new CANNON.ContactMaterial(horseMaterial, groundMaterial, {
                friction: 0.4,
                restitution: 0.7 // Bounciness
            });
            world.addContactMaterial(horseGroundContact);

            // Ground
            const groundShape = new CANNON.Plane();
            groundBody = new CANNON.Body({ mass: 0, shape: groundShape, material: groundMaterial });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to horizontal
            world.addBody(groundBody);

            // Ground Mesh
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterialThree = new THREE.MeshPhongMaterial({ color: 0x4a4e69, side: THREE.DoubleSide });
            groundMesh = new THREE.Mesh(groundGeometry, groundMaterialThree);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Mouse Body (for dragging constraint)
            const mouseShape = new CANNON.Sphere(0.1);
            mouseBody = new CANNON.Body({ mass: 0, shape: mouseShape });
            mouseBody.type = CANNON.Body.KINEMATIC; // Kinematic body is moved manually
            world.addBody(mouseBody);
        }

        /**
         * Creates a new horse, adds it to the physics world, and stores its body and mesh.
         * @param {number} x Initial X position
         * @param {number} y Initial Y position
         * @param {number} z Initial Z position
         */
        function addHorse(x, y, z) {
            // 1. Cannon Body (Box shape for collision)
            const horseSize = new CANNON.Vec3(0.02, 0.02, 0.02); 
            const horseShape = new CANNON.Box(horseSize);
            // Mass is 1.0 (heavy)
            const body = new CANNON.Body({ mass: 1.0, shape: horseShape, position: new CANNON.Vec3(x, y, z) });
            body.linearDamping = 0.3; // Less air drag
            body.angularDamping = 0.5; // More rotational stability
            world.addBody(body);
            horseBodies.push(body);

            // 2. Three Mesh (Loading the GLTF Model)
            const meshGroup = new THREE.Group(); 
            scene.add(meshGroup);
            meshGroup.visible = false; 
            horseMeshes.push(meshGroup);

            // Map the mesh group back to its physics body for easy lookup during dragging
            meshGroup.userData.physicsBody = body;
            
            const loader = new THREE.GLTFLoader();
            const MODEL_URL = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/models/gltf/Horse.glb'; 

            loader.load(
                MODEL_URL,
                function (gltf) {
                    const model = gltf.scene;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.material.side = THREE.DoubleSide; 
                        }
                    });

                    // Visual scale (extremely tiny)
                    const scaleFactor = 0.02; 
                    model.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    
                    // Move the model down so its base aligns with the physics body's center (Y=0)
                    model.position.y = -horseSize.y; 

                    meshGroup.clear();
                    meshGroup.add(model);
                    meshGroup.visible = true;
                    
                    meshGroup.position.copy(body.position);
                },
                undefined, // Progress is ignored for simplicity
                function (error) {
                    console.error('An error happened loading the model, using fallback:', error);
                    // Fallback to the original simple box if the model fails to load
                    const fallbackGeometry = new THREE.BoxGeometry(horseSize.x * 2, horseSize.y * 2, horseSize.z * 2);
                    const fallbackMaterial = new THREE.MeshPhongMaterial({ color: 0xcc0000, shininess: 50 });
                    const fallbackMesh = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                    fallbackMesh.castShadow = true;
                    
                    meshGroup.clear();
                    meshGroup.add(fallbackMesh);
                    meshGroup.visible = true;
                }
            );
        }

        function createMultipleHorses() {
            // Spawn 5 initial horses
            addHorse(0, 5, 0);
            addHorse(2, 6, -1);
            addHorse(-2, 7, 1);
            addHorse(1, 8, 3);
            addHorse(-3, 9, -2);
            
            // Spawn 5 additional horses (New)
            addHorse(4, 5.5, 2);
            addHorse(-4, 6.5, -3);
            addHorse(3, 7.5, -4);
            addHorse(-1, 8.5, 4);
            addHorse(0, 9.5, 5);
        }

        // --- Event Handlers ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            event.preventDefault();
            draggedHorseBody = null;
            isDragging = false;

            // 1. Update mouse coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 2. Raycast to find any horse (intersects the array of all horse meshes)
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(horseMeshes, true); 

            if (intersects.length > 0) {
                isDragging = true;
                const intersectionPoint = intersects[0].point;
                
                // Traverse up the parent hierarchy to find the main mesh group (which stores the physics body reference)
                let draggedMesh = intersects[0].object;
                while (draggedMesh && !draggedMesh.userData.physicsBody && draggedMesh.parent !== scene) {
                    draggedMesh = draggedMesh.parent;
                }
                
                // Assign the physics body from the mesh's userData
                draggedHorseBody = draggedMesh.userData.physicsBody;

                if (!draggedHorseBody) {
                    isDragging = false;
                    return;
                }
                
                // 3. Set the mouse body position to the intersection point
                mouseBody.position.copy(intersectionPoint);

                // 4. Create a point-to-point constraint between the dragged horse and the mouse body
                const anchorA = new CANNON.Vec3().copy(intersectionPoint).vsub(draggedHorseBody.position);
                const anchorB = new CANNON.Vec3(0, 0, 0); 
                const localPivot = draggedHorseBody.pointToLocalFrame(anchorA);
                
                constraint = new CANNON.PointToPointConstraint(draggedHorseBody, localPivot, mouseBody, anchorB);
                world.addConstraint(constraint);

                // Stop the horse's movement when grabbed
                draggedHorseBody.velocity.set(0, 0, 0);
                draggedHorseBody.angularVelocity.set(0, 0, 0);

                velocityHistory.length = 0;
            }
        }

        function onPointerMove(event) {
            event.preventDefault();

            // 1. Update current mouse position
            lastMousePos.copy(currentMousePos);
            currentMousePos.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);

            if (isDragging) {
                // 2. Calculate new world position for the constraint point
                const newWorldPos = getWorldPosition(currentMousePos, plane);

                if (newWorldPos) {
                    // 3. Move the kinematic mouse body to the new world position
                    mouseBody.position.copy(newWorldPos);

                    // 4. Store the current constraint position for throw velocity calculation
                    velocityHistory.push({
                        pos: new THREE.Vector3().copy(newWorldPos),
                        time: Date.now()
                    });

                    // Keep velocity history small
                    if (velocityHistory.length > 5) {
                        velocityHistory.shift();
                    }
                }
            }
        }

        function onPointerUp(event) {
            if (isDragging && constraint && draggedHorseBody) {
                isDragging = false;

                // 1. Calculate and apply throwing impulse
                const impulse = calculateThrowImpulse();
                
                draggedHorseBody.applyImpulse(new CANNON.Vec3(impulse.x, impulse.y, impulse.z), draggedHorseBody.position);

                // 2. Remove the constraint and clear the dragged horse reference
                world.removeConstraint(constraint);
                constraint = null;
                draggedHorseBody = null; 
            }
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            // Physics step
            const delta = clock.getDelta();
            // Using 10 maxSubSteps for improved stability with small, heavy bodies
            world.step(timeStep, delta, 10); 

            // Synchronize all Three.js meshes with their corresponding Cannon.js bodies
            for (let i = 0; i < horseBodies.length; i++) {
                const body = horseBodies[i];
                const mesh = horseMeshes[i];
                if (mesh.visible) {
                    mesh.position.copy(body.position);
                    mesh.quaternion.copy(body.quaternion);
                }
            }

            // If dragging, update the plane position to follow the horse
            if (isDragging && plane) {
                // Keep the plane at a fixed distance from the camera along the Z axis of the intersection
                const currentWorldPos = getWorldPosition(currentMousePos, plane);
                if (currentWorldPos) {
                     // Get the distance from the camera to the constraint point
                    const distance = camera.position.distanceTo(currentWorldPos);
                    
                    // Set a new plane that is parallel to the screen at that distance
                    plane.setFromNormalAndCoplanarPoint(
                        camera.getWorldDirection(new THREE.Vector3()), 
                        currentWorldPos
                    );
                }
            }

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Initialization ---

        window.onload = function () {
            initThree();
            initCannon();
            createMultipleHorses();
            animate();
        };

    </script>
</body>
</html>
