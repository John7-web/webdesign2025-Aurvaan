<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Physics Horse Simulator</title>
    <!-- Load Tailwind CSS for utility classes --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Cannon.js for physics simulation --><script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- Load GLTFLoader for complex 3D models --><script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #87ceeb; /* Light blue background for the sky */
        }
        #info-box {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            font-size: 1rem;
            text-align: center;
            z-index: 10;
            /* Added flex for internal layout of text and button */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #info-box p.small-text {
            font-size: 0.85rem;
            margin-top: 5px;
            margin-bottom: 5px;
            font-weight: 500;
        }
        canvas {
            display: block;
            cursor: grab; /* Hint that the scene is draggable */
        }
    </style>
</head>
<body>

    <div id="info-box" class="shadow-xl">
        <p class="mb-1"><strong>10 Tiny, Heavy Physics Horses!</strong></p>
        <p class="small-text">Click/Tap & Drag to Pick Up and Throw.</p>
        <p class="small-text mb-3">Drag empty space to **Rotate Camera**. Use **Arrows / WASD** to **Move Camera**.</p>
        <!-- NEW BUTTON ADDED HERE --><button id="throw-button" onclick="throwAllHorses()" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition duration-200 transform hover:scale-105 active:scale-95">
            LAUNCH THE HERD!
        </button>
    </div>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let world, groundBody, groundMesh;
        let raycaster, mouse, plane;
        let isDragging = false; // For dragging horses
        let constraint, mouseBody;
        let draggedHorseBody = null; // Track the horse currently being dragged
        let horseBodies = []; // Array to hold all Cannon bodies
        let horseMeshes = []; // Array to hold all Three meshes
        
        let clock = new THREE.Clock();
        const timeStep = 1 / 60;

        // Velocity tracking for throwing
        let lastMousePos = new THREE.Vector2();
        let currentMousePos = new THREE.Vector2();
        const velocityHistory = [];

        // Camera Control Variables
        let isCameraDragging = false;
        const cameraDistance = 15; // Fixed distance from the center
        let cameraPhi = Math.PI / 3; // Vertical angle (controls height, 0 is top, PI is bottom)
        let cameraTheta = Math.PI / 4; // Horizontal angle (controls rotation around Y-axis)
        let previousMousePosition = { x: 0, y: 0 }; // Used for calculating camera rotation delta
        const rotationSpeed = 0.005; // Sensitivity of mouse rotation

        // Translation additions (NEW)
        let cameraTarget = new THREE.Vector3(0, 0, 0); // The point the camera orbits around and looks at
        const cameraMoveSpeed = 0.3; // Speed for translational movement

        // Keyboard state tracking (NEW)
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
        };

        // --- Utility Functions ---

        /**
         * Converts normalized device coordinates to a 3D world position on a specified plane.
         * @param {THREE.Vector2} normalizedCoords - Normalized device coordinates (-1 to 1).
         * @param {THREE.Plane} projectionPlane - The plane to intersect with.
         * @returns {THREE.Vector3 | null} The intersection point or null.
         */
        function getWorldPosition(normalizedCoords, projectionPlane) {
            raycaster.setFromCamera(normalizedCoords, camera);
            const intersection = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(projectionPlane, intersection)) {
                return intersection;
            }
            return null;
        }

        /**
         * Calculates a throwing impulse based on the change in mouse position.
         * Uses the mass of the currently dragged horse.
         * @returns {THREE.Vector3} The calculated impulse vector.
         */
        function calculateThrowImpulse() {
            if (velocityHistory.length < 2 || !draggedHorseBody) return new THREE.Vector3(0, 0, 0);

            // Simple average velocity over the last few frames
            let totalVelocity = new THREE.Vector3(0, 0, 0);
            for (let i = 1; i < velocityHistory.length; i++) {
                const { pos: current, time: t1 } = velocityHistory[i];
                const { pos: prev, time: t0 } = velocityHistory[i - 1];

                const dt = (t1 - t0) / 1000; // time delta in seconds
                if (dt > 0) {
                    const dx = (current.x - prev.x) / dt;
                    const dy = (current.y - prev.y) / dt;
                    const dz = (current.z - prev.p) / dt;
                    totalVelocity.add(new THREE.Vector3(dx, dy, dz));
                }
            }

            const avgVelocity = totalVelocity.divideScalar(velocityHistory.length - 1);

            // Apply a multiplier for a satisfying throw
            const impulseMultiplier = 3; // Weak throwing power
            return avgVelocity.multiplyScalar(draggedHorseBody.mass * impulseMultiplier);
        }

        /**
         * Applies a large, random impulse to all horses, throwing them across the scene.
         */
        function throwAllHorses() {
            const forceMagnitude = 30; // Strong magnitude for mass=1.0 horses
            horseBodies.forEach(body => {
                // Generate a random vector for direction
                const randomX = (Math.random() - 0.5) * 2; // -1 to 1
                const randomY = Math.random() * 1.5 + 1; // 1.0 to 2.5 (mostly upwards)
                const randomZ = (Math.random() - 0.5) * 2; // -1 to 1

                const direction = new THREE.Vector3(randomX, randomY, randomZ).normalize();
                
                // Scale the direction by the desired magnitude
                const impulseVector = direction.multiplyScalar(forceMagnitude);

                // Apply the impulse at the center of mass
                body.applyImpulse(
                    new CANNON.Vec3(impulseVector.x, impulseVector.y, impulseVector.z), 
                    body.position
                );
                
                // Also give a random angular velocity for spinning chaos
                body.angularVelocity.set(
                    (Math.random() - 0.5) * 15, // Increased spin for chaos
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 15
                );
            });
        }
        
        /**
         * Updates the camera position based on the spherical angles (phi and theta) relative to the cameraTarget.
         */
        function updateCameraPosition() {
            // Calculate spherical coordinates (r, theta, phi) relative to cameraTarget
            const x = cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            const y = cameraDistance * Math.cos(cameraPhi);
            const z = cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta);

            // Camera position is offset from the target
            camera.position.set(x, y, z).add(cameraTarget); 
            camera.lookAt(cameraTarget); // Always look at the target point
        }

        // --- Keyboard Controls (NEW) ---

        /**
         * Updates the keyboard state when a key is pressed or released.
         */
        function handleKeyAction(event, isDown) {
            // Prevent default behavior (like scrolling) for arrow keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 's', 'a', 'd'].includes(event.key)) {
                event.preventDefault();
            }

            const key = event.key.toLowerCase();
            switch (key) {
                case 'arrowup':
                case 'w':
                    keys.forward = isDown;
                    break;
                case 'arrowdown':
                case 's':
                    keys.backward = isDown;
                    break;
                case 'arrowleft':
                case 'a':
                    keys.left = isDown;
                    break;
                case 'arrowright':
                case 'd':
                    keys.right = isDown;
                    break;
            }
        }

        /**
         * Sets up the global keyboard listeners.
         */
        function setupKeyboardControls() {
            window.addEventListener('keydown', (event) => handleKeyAction(event, true));
            window.addEventListener('keyup', (event) => handleKeyAction(event, false));
        }

        // --- Setup Functions ---

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50); // Light blue fog
            scene.background = new THREE.Color(0x87ceeb); // Light blue background

            // Camera: Position will be set by updateCameraPosition later
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Interaction Setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Ground plane for dragging

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
        }

        function initCannon() {
            // World
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            // Increased solver iterations from 10 to 20 for maximum contact resolution accuracy
            world.solver.iterations = 20; 

            // Materials 
            const groundMaterial = new CANNON.Material('groundMaterial');
            const horseMaterial = new CANNON.Material('horseMaterial');
            const horseGroundContact = new CANNON.ContactMaterial(horseMaterial, groundMaterial, {
                friction: 0.4,
                restitution: 0.7 // Bounciness
            });
            world.addContactMaterial(horseGroundContact);

            // Ground
            const groundShape = new CANNON.Plane();
            groundBody = new CANNON.Body({ mass: 0, shape: groundShape, material: groundMaterial });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to horizontal
            world.addBody(groundBody);

            // Ground Mesh
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterialThree = new THREE.MeshPhongMaterial({ color: 0x6aa84f, side: THREE.DoubleSide }); // Grass Green
            groundMesh = new THREE.Mesh(groundGeometry, groundMaterialThree);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Mouse Body (for dragging constraint)
            const mouseShape = new CANNON.Sphere(0.1);
            mouseBody = new CANNON.Body({ mass: 0, shape: mouseShape });
            mouseBody.type = CANNON.Body.KINEMATIC; // Kinematic body is moved manually
            world.addBody(mouseBody);
        }

        /**
         * Creates a new horse, adds it to the physics world, and stores its body and mesh.
         * @param {number} x Initial X position
         * @param {number} y Initial Y position
         * @param {number} z Initial Z position
         */
        function addHorse(x, y, z) {
            // 1. Cannon Body (Box shape for collision)
            const horseSize = new CANNON.Vec3(0.02, 0.02, 0.02); 
            const horseShape = new CANNON.Box(horseSize);
            // Mass is 1.0 (heavy)
            const body = new CANNON.Body({ mass: 1.0, shape: horseShape, position: new CANNON.Vec3(x, y, z) });
            body.linearDamping = 0.3; // Less air drag
            body.angularDamping = 0.5; // More rotational stability
            world.addBody(body);
            horseBodies.push(body);

            // 2. Three Mesh (Loading the GLTF Model)
            const meshGroup = new THREE.Group(); 
            scene.add(meshGroup);
            meshGroup.visible = false; 
            horseMeshes.push(meshGroup);

            // Map the mesh group back to its physics body for easy lookup during dragging
            meshGroup.userData.physicsBody = body;
            
            const loader = new THREE.GLTFLoader();
            const MODEL_URL = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/models/gltf/Horse.glb'; 

            loader.load(
                MODEL_URL,
                function (gltf) {
                    const model = gltf.scene;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.material.side = THREE.DoubleSide; 
                        }
                    });

                    // Visual scale (extremely tiny)
                    const scaleFactor = 0.02; 
                    model.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    
                    // Move the model down so its base aligns with the physics body's center (Y=0)
                    model.position.y = -horseSize.y; 

                    meshGroup.clear();
                    meshGroup.add(model);
                    meshGroup.visible = true;
                    
                    meshGroup.position.copy(body.position);
                },
                undefined, // Progress is ignored for simplicity
                function (error) {
                    console.error('An error happened loading the model, using fallback:', error);
                    // Fallback to the original simple box if the model fails to load
                    const fallbackGeometry = new THREE.BoxGeometry(horseSize.x * 2, horseSize.y * 2, horseSize.z * 2);
                    const fallbackMaterial = new THREE.MeshPhongMaterial({ color: 0xcc0000, shininess: 50 });
                    const fallbackMesh = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                    fallbackMesh.castShadow = true;
                    
                    meshGroup.clear();
                    meshGroup.add(fallbackMesh);
                    meshGroup.visible = true;
                }
            );
        }

        function createMultipleHorses() {
            // Spawn 10 horses
            addHorse(0, 5, 0);
            addHorse(2, 6, -1);
            addHorse(-2, 7, 1);
            addHorse(1, 8, 3);
            addHorse(-3, 9, -2);
            addHorse(4, 5.5, 2);
            addHorse(-4, 6.5, -3);
            addHorse(3, 7.5, -4);
            addHorse(-1, 8.5, 4);
            addHorse(0, 9.5, 5);
        }

        // --- Event Handlers ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            event.preventDefault();
            draggedHorseBody = null;
            isDragging = false;
            isCameraDragging = false; // Reset camera drag

            // 1. Update mouse coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Record current mouse position for camera drag
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;

            // 2. Raycast to find any horse (intersects the array of all horse meshes)
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(horseMeshes, true); 

            if (intersects.length > 0) {
                // Horse was hit, start dragging horse logic
                isDragging = true;
                const intersectionPoint = intersects[0].point;
                
                // Traverse up the parent hierarchy to find the main mesh group 
                let draggedMesh = intersects[0].object;
                while (draggedMesh && !draggedMesh.userData.physicsBody && draggedMesh.parent !== scene) {
                    draggedMesh = draggedMesh.parent;
                }
                
                // Assign the physics body from the mesh's userData
                draggedHorseBody = draggedMesh.userData.physicsBody;

                if (!draggedHorseBody) {
                    isDragging = false;
                    return;
                }
                
                // 3. Set the mouse body position to the intersection point
                mouseBody.position.copy(intersectionPoint);

                // 4. Create a point-to-point constraint 
                const anchorA = new CANNON.Vec3().copy(intersectionPoint).vsub(draggedHorseBody.position);
                const anchorB = new CANNON.Vec3(0, 0, 0); 
                const localPivot = draggedHorseBody.pointToLocalFrame(anchorA);
                
                constraint = new CANNON.PointToPointConstraint(draggedHorseBody, localPivot, mouseBody, anchorB);
                world.addConstraint(constraint);

                // Stop the horse's movement when grabbed
                draggedHorseBody.velocity.set(0, 0, 0);
                draggedHorseBody.angularVelocity.set(0, 0, 0);

                velocityHistory.length = 0;
            } else {
                // No horse hit, start camera dragging
                isCameraDragging = true;
                renderer.domElement.style.cursor = 'grabbing';
            }
        }

        function onPointerMove(event) {
            event.preventDefault();

            // 1. Update current mouse position (for horse throwing)
            lastMousePos.copy(currentMousePos);
            currentMousePos.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);

            if (isDragging) {
                // Horse Dragging Logic
                // 2. Calculate new world position for the constraint point
                const newWorldPos = getWorldPosition(currentMousePos, plane);

                if (newWorldPos) {
                    // 3. Move the kinematic mouse body to the new world position
                    mouseBody.position.copy(newWorldPos);

                    // 4. Store the current constraint position for throw velocity calculation
                    velocityHistory.push({
                        pos: new THREE.Vector3().copy(newWorldPos),
                        time: Date.now()
                    });

                    // Keep velocity history small
                    if (velocityHistory.length > 5) {
                        velocityHistory.shift();
                    }
                }
            } else if (isCameraDragging) {
                // Camera Rotation Dragging Logic
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                cameraTheta -= deltaX * rotationSpeed;
                cameraPhi -= deltaY * rotationSpeed;

                // Keep phi between a small epsilon and PI - epsilon to prevent camera from flipping
                const epsilon = 0.01;
                cameraPhi = Math.max(epsilon, Math.min(Math.PI - epsilon, cameraPhi));

                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }
        }

        function onPointerUp(event) {
            if (isDragging && constraint && draggedHorseBody) {
                isDragging = false;

                // 1. Calculate and apply throwing impulse
                const impulse = calculateThrowImpulse();
                
                draggedHorseBody.applyImpulse(new CANNON.Vec3(impulse.x, impulse.y, impulse.z), draggedHorseBody.position);

                // 2. Remove the constraint and clear the dragged horse reference
                world.removeConstraint(constraint);
                constraint = null;
                draggedHorseBody = null; 
            }
            
            // Camera drag release (NEW)
            isCameraDragging = false;
            renderer.domElement.style.cursor = 'grab'; // Set cursor back to default grab style
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            // Physics step
            const delta = clock.getDelta();
            // Using 10 maxSubSteps for improved stability with small, heavy bodies
            world.step(timeStep, delta, 10); 

            // Synchronize all Three.js meshes with their corresponding Cannon.js bodies
            for (let i = 0; i < horseBodies.length; i++) {
                const body = horseBodies[i];
                const mesh = horseMeshes[i];
                if (mesh.visible) {
                    mesh.position.copy(body.position);
                    mesh.quaternion.copy(body.quaternion);
                }
            }
            
            // --- Camera Translation Movement (NEW) ---
            if (keys.forward || keys.backward || keys.left || keys.right) {
                const direction = new THREE.Vector3();
                // Get the direction the camera is currently looking (from target to camera)
                camera.getWorldDirection(direction); 

                // Calculate the right vector for strafing movement
                const right = new THREE.Vector3().crossVectors(direction, camera.up); 
                right.y = 0; // Keep strafing movement horizontal (XZ plane)
                right.normalize();

                // Forward vector, also keeping movement horizontal
                const forwardXZ = direction.clone();
                forwardXZ.y = 0; // Keep forward/backward movement horizontal (XZ plane)
                forwardXZ.normalize();

                if (keys.forward) {
                    cameraTarget.addScaledVector(forwardXZ, cameraMoveSpeed);
                }
                if (keys.backward) {
                    cameraTarget.addScaledVector(forwardXZ, -cameraMoveSpeed);
                }
                if (keys.left) {
                    cameraTarget.addScaledVector(right, -cameraMoveSpeed);
                }
                if (keys.right) {
                    cameraTarget.addScaledVector(right, cameraMoveSpeed);
                }
            }

            // Update camera position based on calculated angles and new target
            updateCameraPosition();

            // If dragging, update the plane position to follow the mouse
            if (isDragging && plane) {
                // Keep the plane at a fixed distance from the camera along the Z axis of the intersection
                const currentWorldPos = getWorldPosition(currentMousePos, plane);
                if (currentWorldPos) {
                     // Get the distance from the camera to the constraint point
                    const distance = camera.position.distanceTo(currentWorldPos);
                    
                    // Set a new plane that is parallel to the screen at that distance
                    plane.setFromNormalAndCoplanarPoint(
                        camera.getWorldDirection(new THREE.Vector3()), 
                        currentWorldPos
                    );
                }
            }

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Initialization ---

        window.onload = function () {
            initThree();
            initCannon();
            // Removed createFences();
            // Removed createBarn();
            setupKeyboardControls(); // Initialize keyboard listeners (NEW)
            createMultipleHorses();
            updateCameraPosition(); // Set initial camera position
            animate();
        };

    </script>
</body>
</html>